#! /usr/bin/env bash

# main for sift tool
# run from within execution dir

export MCC=1
export GOTRACEBAK=0

echoerr() { echo "$@" 1>&2; }

# We only compete in the StateSpace category.
if [ "$BK_EXAMINATION" != "StateSpace" ]
then echoerr StateSpace False; echo DO_NOT_COMPETE; exit 0
else echoerr StateSpace True
fi

name=$BK_INPUT
heap="@MLton fixed-heap 15G --"
options="-auto -count-transitions -count-tokens"
# after timeout, calls tina to detect possible unboundedness
timeout=3500
# timeout=10

if [ `cat iscolored` == "TRUE" ]

then echoerr Colored True
    if [ -f NewModel ]

    then
	echoerr Known False
	echoerr calling mcc
	mcc hlnet -i model.pnml
	res=$?
	sync
	if [ "$res" != "0" ]
	then echoerr mcc failure with status $res; echo CANNOT COMPUTE; exit 0
	else echoerr mcc success
	fi
	echoerr sift on `ls model.*t*`
	sift $heap $options model.*t* output digest
	res=$?

    else
	echoerr Known True
	if [ -f $bin/net/$name.net ]
	then echoerr sift on net;
	    sift $heap $options $bin/net/$name.net output digest
	    res=$?
	else
	    echo DO_NOT_COMPETE; exit 0
	fi
    fi

else
    echoerr Colored False
    if [ -f NewModel ]

    then
	echoerr Known False
	# calling sift portfolio for new models
	timeout --preserve-status $timeout /bin/sh -c "echo "$@" 1>&2 sift on pnml; sift $heap $options model.pnml output digest" ||
	timeout --preserve-status 30 /bin/sh -c "echo "$@" 1>&2 tina on pnml; tina model.pnml output digest -q"
	res=$?

    else
	echoerr Known True
	# calling sift portfolio for known
	timeout --preserve-status $timeout /bin/sh -c "\
             (test -f $bin/sym/$name.tpn && (echo "$@" 1>&2 syft on tpn; syft $heap -cnt $bin/sym/$name.tpn output digest)) || \
             (echo "$@" 1>&2 sift on pnml; sift $heap $options model.pnml output digest)" ||
	timeout --preserve-status 30 /bin/sh -c "echo "$@" 1>&2 tina on pnml; tina model.pnml output digest -q"
	res=$?
    fi
fi

if [ "$res" != "0" ]
then echoerr failure with status $res; echo CANNOT COMPUTE; exit 0
else echoerr success
fi

if [ -f results.json ]
then
    # print results using jq  (1.5 requird; spaces in keys not supported by default 1.3 in 14.04)
    sync
    tech='TECHNIQUES EXPLICIT STRUCTURAL_REDUCTION COMPRESSED_STATES SEQUENTIAL_PROCESSING'
    states=`jq -r .states results.json`
    transitions=`jq -r .transitions results.json`
    ptokens=`jq -r .ptokens results.json`
    mtokens=`jq -r .mtokens results.json`

    echo STATE_SPACE STATES $states $tech
    echo STATE_SPACE TRANSITIONS $transitions $tech
    echo STATE_SPACE MAX_TOKEN_IN_PLACE $ptokens $tech
    echo STATE_SPACE MAX_TOKEN_PER_MARKING $mtokens $tech

else
    # results.json not found ...
    echo CANNOT COMPUTE
fi
